/**
 * @module Taxon
 * @author Erik Pearson
 * @version 0.1.0
 * @param {TaxonLibrary} taxon
 * @param {TriftLibrary} Thrift
 * @param {BluebirdPromise} Promise
 * @returns {Taxon_L12.factory}
 */
/*global define*/
/*jslint white: true, browser: true*/
define([
    'bluebird',
    './taxon/thrift_service',
    'kb/thrift/core',
    './common',
    // These don't have representations. Loading them causes the Thrift module
    // to be enhanced with additional properties (typically just a single
    //  property, the new capability added.)
    'kb/thrift/transport/xhr',
    'kb/thrift/protocol/binary'
], function (Promise, taxon, Thrift, common) {
    'use strict';

    /**
     * Represents an interface to the Taxon data service.
     * @alias module:Taxon
     * @constructs Taxon
     * @param {object} config
     * @param {ObjectReference} config.ref The object reference for the object to be accessed.
     * @param {string} config.url The url for the Taxon Service endpoint.
     * @param {string} config.token The KBase authorization token to be used to access the service.
     * @returns {Taxon} A taxon api object
     */
    function makeTaxonClient(config) {
        var objectReference,
            serviceUrl,
            authToken,
            timeout;

        common.validateCommonApiArgs(config);

        objectReference = config.ref;
        serviceUrl = config.url;
        authToken = config.token;
        timeout = config.timeout;


        /**
         * Creates and returns an instance of the Taxon Thrift client. Note that
         * this is
         *
         * @returns {Taxon_L22.taxon.thrift_serviceClient}
         * @private
         * @ignore
         */
        function client() {
            try {
                var transport = new Thrift.TXHRTransport(serviceUrl, {timeout: timeout}),
                    protocol = new Thrift.TBinaryProtocol(transport),
                    thriftClient = new taxon.thrift_serviceClient(protocol);
                return thriftClient;
            } catch (ex) {
                // Rethrow exceptions in our format:
                if (ex.type && ex.name) {
                    throw ex;
                }
                throw new TaxonException({
                    type: 'ThriftError',
                    message: 'An error was encountered creating the thrift client objects',
                    suggestion: 'This could be a configuration or runtime error. Please consult the console for the error object',
                    errorObject: ex
                });
            }
        }


        /**
         * If the Taxon has a parent object, this is returned. Otherwise,
         * it is ...
         *
         * @returns {Promise<ObjectReference|Error>} An object reference string
         * @throws {ThriftClientError} For networking and client side issues. These errors
         * are detected by the front end (javascript) code.
         * @throws {ThriftServiceError} For errors generated by the back end service.
         *
         */
        function parent() {
            return client().get_parent(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         * Get a array of object reference strings which are children (sub objects)
         * of this Taxon.
         *
         * @returns {Array<ObjectReference>} An array of object references representing the children of this object.
         */
        function children() {
            return client().get_children(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         *
         * @returns {Array<String>} An array of genome annotation strings
         */
        function genome_annotations() {
            return client().get_genome_annotations(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         * Get a list of taxonomic groups the species belongs to, with least specific first,
         * and most specific, that is the species itself, last.
         *
         * @returns {Array<String>} The lineage for this taxon, as an ordered list of taxonomic
         * ranks from least specific to most specific.
         *
         * @example
         *
         * Life
         *   Domain
         *     Kingdom
         *       Phylum
         *         Clas
         *           Order
         *             Family
         *               Genus
         *                 Species
         *
         */
        function scientific_lineage() {
            return client().get_scientific_lineage(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         *
         * @returns {String}
         */
        function scientific_name() {
            return Promise.try(function () {
                return client().get_scientific_name(authToken, objectReference, true)                
                    .catch(taxon.AttributeException, function (err) {
                        return undefined;
                    });;
            });
        }

        /**
         *
         * @returns {Number}
         */
        function taxonomic_id() {
            return client().get_taxonomic_id(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });            
        }

        /**
         *
         * @returns {String}
         */
        function kingdom() {
            return client().get_kingdom(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         *
         * @returns {String}
         */
        function domain() {
            return client().get_domain(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         * The NCBI genetic code for the species.
         *
         * @returns {Number}
         * @see {@link http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi} NCBI "The Genetic Codes"
         */
        function genetic_code() {
            return client().get_genetic_code(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        /**
         *
         * @returns {Array<String>}
         */
        function aliases() {
            return client().get_aliases(authToken, objectReference, true)
                .catch(taxon.AttributeException, function (err) {
                    return undefined;
                });
        }

        // API
        return Object.freeze({
            parent: parent,
            children: children,
            genome_annotations: genome_annotations,
            scientific_lineage: scientific_lineage,
            scientific_name: scientific_name,
            taxonomic_id: taxonomic_id,
            kingdom: kingdom,
            domain: domain,
            genetic_code: genetic_code,
            aliases: aliases
        });
    };

    var api = {
        client: function (config) {
            return makeTaxonClient(config);
        },
        ClientException: common.ClientException,
        ServiceException: taxon.ServiceException,
        AuthorizationException: taxon.AuthorizationException,
        AuthenticationException: taxon.AuthenticationException,
        ObjectReferenceException: taxon.ObjectReferenceException,
        AttributeException: taxon.AttributeException,
        TypeException: taxon.TypeException
    };
     
    for (var propKey in Thrift) {
        if (propKey.match(/Exception$/)) {
            api[propKey] = Thrift[propKey];
        }
    }
    return Object.freeze(api);   
});